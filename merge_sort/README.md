# Merge Sort

This algorithm is different from the others we've seen, it uses a different approach to solve the problems of sorting a set of numbers. This approach is known as the ***"Divide and Conquer method"***, separating the input array into two halves. And so on, the algorithm continues to divide the array into two parts, until such time as we have sub-arrays of just one element. After that, we can see the code logic start to work, the merge sort algorithm assumes that we have two arrays already classified and we need to merge them into one. An array of one element is already sorted, we just need to combine the elements, pair by pair, with the smalleste element on the left and the bigger on the right.

Now we have increased the size of the pieces, we have merged sub-arrays of 2 elements, we can trust that they were classified in the previous passage. The algorithm will place first the smallest elements of both parts, after that, we continue to increase the size of the sub-parts that we need to merge, at each stage the parts are merged and sorted. If the two sub-arrays are not the same size, when the first one finishes, we just need to copy the other one, because we can assume that in the previous passages, this part has already been sorted.

Another behavior of this algorithm that differs from the others is in relation to the complexity of time and space in memory. This algorithm is capable of sorting a list of numbers in a time complexity of **O(n*logn)**, this is the fastest method we have seen so far, but to achieve this performance, we need to pay a price in memory, we will need an auxiliary array with the same size as the input array to overwritte the sorted arrays and allow the algorithm to merge the sub-arrays into each recursive call. For this reason, the memory complexity of the merge sort algorithm is **O(n)**.

By running the algorithm we are able to see its capacity, to inputs of **10⁵** elements, the merge took almost a hundredth of a second to sort the entire list of elements. This is the first algorithm that allow us to see its performance at an input greater than 10⁶.

In this repository, we have two versions of the algorithm, the first, merge_sort.c, is the iterative version. This algorithm accesses all elements of the array using a 'for loop' that has been updated with a logarithmic factor. The second code, mergeR.c, makes use of recursion, it means to call the function itself, at each call, the function divided the array into two halves and called itself again for each half and continued doing this until the moment in that the input array was divided into pieces the size of an element. After running the two versions of the algorithm, we are able to see that the iterative version was slightly faster than the recursive version.
