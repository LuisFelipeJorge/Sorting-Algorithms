# Selection Sort

This algorithm works with the idea of sorting a stack of paper. We will find the smallest element in our set of numbers and then place that number in the correct position within the array, checking all the leaves that come before it. Another way to understand its behavior is to think that the algorithm assumes that the array is divided into two parts, one that is already ordered and the other that is not. At the beginning, the ordering part is empty and the unordered part is the entire array. The algorithm finds the smallest element and then changes it to the leftmost element of the unordered array so the ordered part starts to grow, the replaced element becomes part of the ordered array. This process is repeated element by element, moving the boundary of the ordered array, until the unordered part is empty.

When analyzing the behavior of the selection sorting sort algorithm, we can see that they have a better result compared to the first version of the bubble sort algorithm. The selection sort performs fewer movements, because it changes two elements of the array only at the moment in which one of them is in the correct position, we can perceive that its swap complexity is linear, that is, **O(n)**. We can see the difference in larger entries, arrays with more than 10,000 elements.

However, in order to find the correct position of a particular element, the selection sort must compare it with all other elements of the array. This behavior makes the complexity of the algorithm square in its worst scenario (an inversely ordered input), where it would have to check the entire vector for each element.

Therefore, the selection has **O(nÂ²)** time complexity and, as it does not use extra memory, **O(1)** space complexity. Therefore, we do not gain much by using this approach to sort large arrays.